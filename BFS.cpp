#include "BFS.h"

std::vector<Point> bfs(const Graph& graph, const Point& start, const Point& end) {
    // Основное отличие реализации BFS и DFS - в BFS используется очередь
    // Очередь для хранения точек, которые нужно обработать
    std::queue<Point> queue; // 16n байт, где n - кол-во элементов

    // Хэш мап для хранение родительской точки для каждой посещенной точки (для восстановления пути)
    std::unordered_map<Point, Point, PointHash> parent; // (16 + 16) * n = 32n байта

    // Хэш мап для отслеживания посещенных точек
    std::unordered_map<Point, bool, PointHash> visited; // (16 + 1) * n = 17n байт

    // Вектор для хранения пути от начальной до конечной точки (результат)
    std::vector<Point> path; // 16k байт

    // Добавляем начальную точку в очередь и помечаем ее как посещенную
    queue.push(start); // 16 байт
    visited[start] = true; // 16 + 1 = 17 байт

    // Пока очередь не пуста, продолжаем обработку
    while (!queue.empty()) { // O(V), где V - кол-во вершин
        // Извлекаем текущую точку из очереди
        Point current = queue.front(); // 16 байт
        queue.pop(); // - 16 байт

        // Если мы достигли конечной точки, восстанавливаем путь
        if (current == end) {
            // Восстанавливаем путь от конечной точки до начальной
            while (current != start) { // O(p), где p - len пути
                path.push_back(current); // 16 байт
                current = parent[current]; 
            }

            path.push_back(start);  // Добавляем начальную точку в путь; 16 байт
            std::reverse(path.begin(), path.end());  // Путь строится в обратном порядке, поэтому переворачиваем его; O(p)
            return path;
        }

        // Получаем текущую точку из графа
        auto iterator = graph.find(current);
            
        // Проходим по всем соседям текущей точки
        for (const auto& neighbor : iterator->second) { // O(E), где E - кол-во ребер
            Point next = neighbor.first;  // Следующая точка для обработки

            // Если точка еще не была посещена, добавляем ее в очередь и помечаем как посещенную
            if (!visited[next]) {
                visited[next] = true;    // Помечаем как посещенную, чтобы не обрабатывать снова; 16 + 1 = 17 байт
                parent[next] = current;  // Устанавливаем родительскую точку; 16 байт
                queue.push(next);        // Добавляем соседнюю точку в очередь; 16 байт
            }
        }
    }

    // Если путь не найден, возвращаем пустой
    return path;

   // Итого по памяти примерно имеем 16n + 32n + 17n + 16k + 16 + 17 + 16 - 16 + 16 + 16 + 17 + 16 + 16 = 65n + 16k + 114 байт.
   // Общая временная сложность - обработка всех рёбер O(E) + O(V) = O(V + E), где V - кол-во вершин, E - кол-во рёбер.
}
